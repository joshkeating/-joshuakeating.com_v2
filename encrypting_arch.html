<!DOCTYPE html><html><head><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" type="text/css" href="style.css"><link rel="shortcut icon" href="/res/favicon.ico"><title>Encrypting Arch Linux</title></head><body><header><div><a class="header-name" href="/">josh keating</a></div><div class="header-links-container"><a href="about.html">About</a><a href="archive.html">Archive</a></div></header><main><div class="post-header-container"><h1 class="post-title">Encrypting Arch Linux</h1><div class="post-date">01/20/2017</div></div><article class="post-content"><p>After deciding to say sayōnara to my previous dual booted system Windows and Arch and go 100 Arch, I came to the realization that this would be a great time to be proactive in securing my data and do some full disk encryption. This will be a brief guide on installing Arch Linux on a new system using <a class="std-link" href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system">LUKS</a> for full-disk encryption and <a class="std-link" href="https://wiki.archlinux.org/index.php/LVM">LVM</a> for volume management. My motivations for writing this guide are not entirely altruistic - this is documentation for future me as much as it is a guide for anyone who stumbles upon this article.</p><h2 class="post-subheading">The Setup</h2><p>You'll need a bootable flash drive loaded with a current version of the ISO image. If you're on Windows it's also a good idea to disable Secure Boot with UEFI enabled. I will also assume that you are using a SATA based hard drive, in the case that your drive is NVMe based keep in mind that the partition naming scheme will differ i.e. <code class="inlinecode">/dev/nmve0</code> vs <code class="inlinecode">/dev/sda</code>.</p><h2 class="post-subheading">Partitioning</h2><p>First we are going to zero out the disk, this is done to ensure that the disk is properly wiped and prepared for encryption. We zero-fill the disk by writing a zero byte to every addressable location on the disk using the <code class="inlinecode">/dev/zero</code> stream.</p><pre class="codeblock">$ cryptsetup open --type plain /dev/sdXY container --key-file /dev/random
$ dd if=/dev/zero of=/dev/mapper/container status=progress</pre><p>We're going to use the GPT partition scheme since we're on a UEFI system.</p><pre class="codeblock">$ gdisk /dev/sda</pre><p>Then we'll set up the ESP and root partitions. There are a number of partitioning tools that you can use, here I will use fdisk. The ESP partition should have a size of 512M and use the partition table type of EFI System EFI System in fdisk or EF00 in gdisk. We can fill the rest of the space with the root partition.</p><pre class="codeblock">$ fdisk /dev/sda
$ mkfs.fat -F32 -nESP /dev/sda1
$ mkfs.ext4 /dev/sda2</pre><h2 class="post-subheading">LUKS Disk Encryption</h2><p>I use LUKS or Linux Unified Key Setup to encrypt my drive for two main reasons, further partitioning is super easy with LVM and it allows for single key authentication to unlock all volumes. The only caveat to this setup in the vulnerability of the bootloader. Though there are steps you can take to secure your boot I will not be covering them here.</p><pre class="codeblock">$ cryptsetup luksFormat /dev/sda2
$ cryptsetup open --type luks /dev/sda2 lvm</pre><h2 class="post-subheading">LVM Filesystem Management</h2><p>Logical Volume Management uses the kernel's device-mapper feature to create virtual partitions that make expanding or shrinking partitions ridiculously easy. LVM also supports snapshots which are an efficient way perform backups. I prefer to keep my partition scheme relatively simple with just root, home, and swap partitions. You can call your physical volume whatever you like, here I call it VirtVol.</p><pre class="codeblock">$ pvcreate /dev/mapper/lvm
$ vgcreate VirtVol /dev/mapper/lvm

$ lvcreate -L 40G VirtVol -n root
$ lvcreate -L 8G VirtVol -n swap
$ lvcreate -l 100%FREE VirtVol -n home

$ mkfs.ext4 /dev/mapper/VirtVol-root
$ mkfs.ext4 /dev/mapper/VirtVol-home
$ mkswap /dev/mapper

$ mount /dev/mapper/VirtVol-root /mnt
$ mkdir /mnt/home
$ mount /dev/mapper/VirtVol-home /mnt/home
$ swapon /dev/mapper/VirtVol-swap</pre><h2 class="post-subheading">Arch Install</h2><p>With the parations all setup now we can install the base system. First we're going to mount the boot partition and then install the base packages.</p><pre class="codeblock">$ mkdir /mnt/boot
$ mount /dev/sda1 /mnt/boot

$ pacstrap /mnt base base-devel</pre><p>Now we generate our filesystem information, and chroot into our new installation.</p><pre class="codeblock">$ genfstab -U /mnt &gt;&gt; /mnt/etc/fstab
$ arch-chroot /mnt /bin/bash</pre><p>Next we're going to want uncomment <code class="inlinecode">en_US.UTF-8</code> to set up UTF-8 character encoding. We also want to generate and create the locale.</p><pre class="codeblock">$ vim /etc/locale.gen
$ locale-gen
$ cat &gt;&gt;/etc/locale.conf
&gt; LANG=en_US.UTF-8</pre><p>Next set up your timezone and sync the hardware clock</p><pre class="codeblock">$ ln -s /usr/share/zoneinfo/America/Los_Angeles /etc/localtime
$ hwclock --systohc --utc</pre><p>Finally we need to configure and generate a new initial ramdisk environment. Remember to take special care to set <code class="inlinecode">encrypt</code> and <code class="inlinecode">lvm</code> to be in front of <code class="inlinecode">filesystem</code> in <code class="inlinecode">HOOKS=”..”</code>.</p><pre class="codeblock">$ vim /etc/mkinitcpio.conf
$ mkinitcpio -p linux</pre><h2 class="post-subheading">Boot Manager</h2><p>The last thing we need to do is set up our boot manager. I use <code class="inlinecode">systemd-boot</code> which works on UEFI systems and is easy to set up. We first need to make sure that the ESP partition is mounted at <code class="inlinecode">/boot</code>. Then install <code class="inlinecode">systemd-boot</code>.</p><pre class="codeblock">$ mount -l | grep boot
$ bootctl install</pre><p>Next we need the UUID of our root partition. Find it with <code class="inlinecode">blkid -s UUID -o value /dev/sda2</code>. We also need to write a boot entry. If you have an Intel processor it's a good idea to include initrd intel-ucode.img in your boot entry, this enables microcode updates for the stability and security of the processor. You will need to install the <code class="inlinecode">intel-ucode</code> package through pacman before this will work however.</p><pre class="codeblock">$ cat &gt;&gt; arch-encrypted-lvm.conf
title Encrypted Arch Linux
linux /vmlinuz-linux
initrd /intel-ucode.img
initrd /initramfs-linux.img
options cryptdevice=UUID=(UUID goes here):VirtVol root=/dev/mapper/VirtVol-root quiet rw</pre><p>Alright we're done Now you can <code class="inlinecode">exit</code>, <code class="inlinecode">reboot</code>, and if you did everything right, be greeted with a login shell.</p></article></main><footer><p>© 2016-2020 Joshua Keating. Generated with <a href="https://github.com/joshkeating/sssgr">sssgr</a></p></footer></body></html>